---
title: 'Preparing stock status data layer derived from the RAM database'
author: "*Compiled on `r date()` by `r Sys.info()['user']`*"
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_depth: 3
    toc_float: yes
    number_sections: true
    theme: cerulean
    highlight: haddock
    includes: 
      in_header: '~/github/ne-prep/src/templates/ohi_hdr.html'
  pdf_document:
    toc: true
---

``` {r setup, echo = FALSE, message = FALSE, warning = FALSE, results = 'hide'}

knitr::opts_chunk$set(fig.width = 6, fig.height = 4, message = FALSE, warning = FALSE)

source('~/github/ne-prep/src/R/common.R')  ### an OHINE specific version of common.R

dir_git <- '~/github/ne-prep'
#dir_rgn <- file.path(dir_git, 'prep/regions')  ### github: general buffer region shapefiles
dir_anx <- file.path(dir_M, 'git-annex/neprep')

library(sf)
```

This script filters the RAM database v4.41 for all stocks in the Northeast region and summarizes the available information for each stock.

***
#Data Source

**Downloaded**: August, 2018 (emailed to us)

**Description**:  RAM Legacy Stock Assessment Database provides information on global fish stocks including catch, B/Bmsy and F/Fmsy among other metrics.

**Time range**: pre-1900 to 2016

**Format**:  Tabular

***
  
#Analysis

What assessment information do we have for these stocks?

```{r, fig.height = 10, fig.width = 8}

#RAM data
assessment_data_file <- file.path(dir_M, 'git-annex/globalprep/_raw_data/RAM/d2018/RAM v4.41 (8-20-18)/DB Files With Assessment Data/DBdata (assessment data only).RData')
load(assessment_data_file)

metadata <- as.data.frame(metadata, stringsAsFactors = FALSE)

#filter metadata from RAM to select only those stocks in the Northeast
ne_stocks <- metadata %>%
  filter(region %in% c("US East Coast", "Atlantic Ocean"),
         areaname != "South Atlantic",
         areaname != "Eastern Atlantic")

### get time series of B/Bmsy and F/Fmsy for NE stocks from .Rdata
ts <- as.data.frame(timeseries_values_views, stringsAsFactors = FALSE) %>%
  filter(stockid %in% ne_stocks$stockid) %>%
  select(stockid, stocklong, year, BdivBmsypref, UdivUmsypref) %>%
  filter(!is.na(BdivBmsypref)) %>%
  gather(key = tsid, value = value, -stockid, -stocklong, -year)

span_df <- ts %>%
  filter(!is.na(value)) %>%
  group_by(stocklong, tsid) %>%
  summarize(yr_min = min(year), yr_max = max(year)) %>%
  ungroup() %>%
  mutate(yr_min = ifelse(yr_min < 1980, 1980, yr_min)) %>% ## some stocks have a really long history (e.g. Atlantic Halibut goes back to pre-1900) so I'm reducing the years to only 1980 for plotting purposes
  mutate(metric = 
           case_when(
             tsid == "BdivBmsypref" ~ "B/Bmsy",
             tsid == "UdivUmsypref" ~ "F/Fmsy"
           ))

stock_ids <- span_df$stocklong %>% unique()

span_plot <- ggplot(span_df, aes(x = stocklong)) +
  #ggtheme_basic +
  theme(panel.border     = element_blank(),
        panel.grid.minor = element_blank(),
        panel.grid.major = element_line(colour = 'grey90'),
        panel.background = element_blank()) +
  annotate('rect', ymin = 2000, ymax = 2016,
           xmin = first(stock_ids), xmax = last(stock_ids),
           fill = 'red', alpha = .1) +
  geom_linerange(aes(ymin = yr_min, ymax = yr_max, 
                     color = metric),
                 position = position_dodge(width = .5), alpha = .8) +
  scale_color_manual(values = c('red', 'blue'),
                       labels=c("B/Bmsy", "F/Fmsy")) +
  coord_flip() +
  labs(x = 'RAM Stock',
       y = 'Year',
       color = 'Parameter')

span_plot

```

# Create layer

```{r}
#get more species specific information from ne_stocks
sp <- ne_stocks %>% 
  select(stockid, stocklong, scientificname, commonname, areaname) %>%
  distinct()

stock_ass_data <- ts %>%
  mutate(metric = 
           case_when(
    tsid == "BdivBmsypref" ~ "B/Bmsy",
    tsid == "UdivUmsypref" ~ "F/Fmsy")) %>%
  select(stockid, stocklong, year, value, metric) %>%
  left_join(sp)

write.csv(stock_ass_data, file = "data/fis_ram_stock_assessment_data.csv")
```

In order to save stocks to the regions where they are caught we need to link the RAM and NOAA data.

```{r}
# read in NOAA catch data that we formatted and saved for the toolbox
noaa <- read.csv(file.path(dir_calc, "layers/fis_meancatch.csv")) 

# get unique species in NOAA dataset
noaa_sp <- noaa %>%
  mutate(common_lower = tolower(species)) %>%
  select(common_lower) %>%
  distinct()
```


There are some weird things going on in the NOAA data. For example, there is both "atlantic herring" and "sea herring". These are two common names for [*Clupea harengus*](https://www.fisheries.noaa.gov/species/atlantic-herring). Quahog clam has three different names; **Ocean quahog clam**, **Quahog clam** and **Northern quahog clam**. The Northern quahog clam is a different species than Ocean quahog, but I'm not sure what the catch designated as simply "Quahog clam" should be as there is no scientific name associated. This is something we need to ask an expert about.

There are likely more species mismatches and name weirdnesses. This is something we need to fix and doublecheck before getting final results.

---

Are there any species in RAM that are not in NOAA

```{r}
ram_sp <- stock_ass_data %>%
  mutate(common_lower = tolower(commonname)) %>%
  select(common_lower) %>%
  distinct()

setdiff(ram_sp, noaa_sp)
```

Ok there are `r nrow(setdiff(ram_sp, noaa_sp))` ram species not in NOAA. But maybe the names just don't match. I know for a fact that menhaden, bluefin, plaice, butterfish and herring are in the NOAA dataset. We just need to get these identified.

```{r}
ram_fixed <- stock_ass_data %>%
  mutate(common_lower = tolower(commonname),
         common_lower_noaa = case_when(
           common_lower == "atlantic menhaden" ~ "menhaden",
           common_lower == "atlantic bluefin tuna" ~ "bluefin tuna",
           common_lower == "american plaice" ~ "flounder,atlantic,plaice",
           common_lower == "herring" ~ "atlantic herring",
           common_lower == "ocean quahog" ~ "ocean quahog clam",
           common_lower == "spiny dogfish" ~ "spiny dogfish shark",
           common_lower == "atlantic surfclam" ~ "atlantic surf clam",
           common_lower == "tilefish" ~ "golden tilefish",
           common_lower == "smooth dogfish" ~ "smooth dogfish shark",
           common_lower == "atlantic butterfish" ~ "butterfish",
           common_lower == "red deepsea crab" ~ "deepsea red crab",
           common_lower == "scalloped hammerhead" ~ "hammerhead shark",
           common_lower == "windowpane" ~ "windowpane flounder"
         )) %>%
  mutate(species = ifelse(is.na(common_lower_noaa), common_lower, common_lower_noaa)) %>%
  select(-common_lower, -common_lower_noaa)

write.csv(ram_fixed, file = "data/ne_ram_data.csv")
```

**NOTES**
Monkfish and Sailfish are the only species in the RAM database w/ B/Bmsy (filtered for the US Northeast) that do not appear in NOAA catch statistics.

Are there multiple stocks of a single species? If so this means we need to identify where stocks are fished. 

```{r}
dups <- ram_fixed %>%
  select(species, stocklong, areaname) %>%
  distinct() %>%
  arrange(species)

DT::datatable(dups)
```


Just by looking at the table, it seems there are a few sub-species stocks including:  
- Atlantic cod (George's Bank and Gulf of Maine are two different stocks)  
- Haddock (George's Bank and Gulf of Maine are two different stocks)  
- Monkfish (seems like a Southern and Northern that might be our region and the mid-atlantic)  
- Winter flounder (George's Bank and Southern New England/Mid-Atlantic)  
- Yellowtail flounder (Cape Cod/Gulf of Maine and Southern New England/Mid-Atlantic)  
- Windowpane flounder  

I did some visual inspection of the shapefiles for these stocks from [Chris Free's database](https://marine.rutgers.edu/~cfree/ram-legacy-stock-boundary-database/) and it does seem that all of these touch our regions. Initially I was going to pull the shapefiles for each of these stocks and then assign catch based on the region they touch. For example catch of Yellowtail flounder landed in Connecticut would be assigned to the Southern New England/Mid-Atlantic stock. But I don't think this is appropriate. We need to **check with NEFSC folks** about this. But I imagine fisherman/woman are not this selective and could possibly be landing Yellowtail from either stock. So for now I am going to calculate an average stock score for each of these species.


I want to look just at b/bmsy & f/fmsy of each stock.


# Visualize

```{r, fig.width = 10, fig.height = 8}
sp <- unique(ram_fixed$stockid)

plot_1_df <- ram_fixed %>%
  filter(stockid %in% sp[1:22])

ggplot(plot_1_df, aes(x = year, y = value, color = metric)) +
  geom_hline(yintercept = 1.0, color = "black") +
  geom_line() +
  facet_wrap(~stockid, scales = 'free') +
  theme_bw()

plot_2_df <- ram_fixed %>%
  filter(stockid %in% sp[23:44])

ggplot(plot_2_df, aes(x = year, y = value, color = metric)) +
  geom_hline(yintercept = 1.0, color = "black") +
  geom_line() +
  facet_wrap(~stockid, scales = 'free') +
  theme_bw()
```

## Calculate stock scores

Convert these value to stock scores.

```{r stock_score_calc}

#grab just B/Bmsy data
  ram_b_bmsy <- ram_fixed %>%
    filter(metric == "B/Bmsy") %>%
    select(stockid, stocklong, species, year, value) %>%
    rename(b_bmsy = value)

#grab just F/Fmsy data  
  ram_f_fmsy <- ram_fixed %>%
    filter(metric == "F/Fmsy") %>%
    select(stockid, stocklong, species, year, value)
  ### 
  b_bmsy_underexploit_penalty <- 0.25
  b_bmsy_underexploit_thresh  <- 3.00
  f_fmsy_underfishing_penalty <- 0.25
  f_fmsy_overfishing_thresh   <- 2.00
  
  ### Apply rolling mean to F/Fmsy
  ## Why do we do this? because B is a less sensitive metric (relies of biological processes) and F can fluctuate pretty easily because it is really just a mgmt decision.
  ram_f_fmsy <- ram_f_fmsy %>%
    mutate(f_fmsy= value) %>%
    arrange(stockid, year) %>%
    group_by(stockid) %>%
    mutate(f_fmsy_rollmean = zoo::rollmean(f_fmsy, k = 3, align = 'right', fill = NA)) %>%
    ungroup() %>%
    select(-value, -f_fmsy) %>%
    rename(f_fmsy = f_fmsy_rollmean)
  
  stock_status_layers <- ram_b_bmsy %>%
    full_join(ram_f_fmsy)
  
########################################################.
##### run each fishery through the Kobe plot calcs #####
########################################################.
### * ram_b_bmsy, ram_f_fmsy
  
  
### Function for converting B/Bmsy values into a 0 - 1 score
  rescale_bprime_crit <- function(fish_stat_df,
                                  bmax, bmax_val) {
    
    ###using NOAA's limits here
    overfished_th  <- 0.8
    ### 
    underfished_th <- 1.2
    
    bmax_adj <- (bmax - underfished_th) / (1 - bmax_val) + underfished_th
    ### this is used to create a 'virtual' B/Bmsy max where score drops
    ### to zero.  If bmax_val == 0, this is bmax; if bmax_val > 0, bmax_adj
    ### extends beyond bmax, to create a gradient where bmax_val occurs at bmax.
    
    fish_stat_df <- fish_stat_df %>%
      # group_by(stock) %>% ### grouping by stock will set b_max by max per stock, instead of max overall
      mutate(b_max     = max(b_bmsy, na.rm = TRUE)) %>%
      ungroup() %>%
      mutate(bPrime = NA,
             bPrime = ifelse(b_bmsy < overfished_th,  ### overfished stock
                             b_bmsy / overfished_th,
                             bPrime),
             bPrime = ifelse(b_bmsy >= overfished_th & b_bmsy < underfished_th,
                             1,                       ### appropriately fished stock
                             bPrime),
             bPrime = ifelse(b_bmsy >= underfished_th,
                             (bmax_adj - b_bmsy) / (bmax_adj - underfished_th), ### underfished stock
                             bPrime),
             bPrime = ifelse(bPrime < 0, 0, bPrime))
    return(fish_stat_df)
  }
  
  
  ### Function to create vertical gradient based on distance from
  ### ideal F/Fmsy value to actual F/Fmsy value
  f_gradient <- function(f, over_f, under_f, fmax, fmin_val) {
    x <- ifelse(f < over_f & f > under_f, 1, NA)
    x <- ifelse(f <= under_f, (f * (1 - fmin_val) / under_f + fmin_val), x)
    x <- ifelse(f >= over_f,  (fmax - f) / (fmax - over_f), x)
    x <- ifelse(f > fmax, NA, x)
    return(x)
  }
  
  ### Function to convert F/Fmsy values into 0 - 1 score
  rescale_fprime_crit <- function(fish_stat_df,
                                  fmax, fmin_val) {
    
    ### params - taken from BC but changed Bcrit to 0 instead of 0.4:
    Bcrit <- 0.5; overfished_th <- 0.8
    ### underfishing_th is set to the idea "1/3 for the birds":
    underfishing_th <- 0.66; overfishing_th  <- 1.2
    
    bcritslope = 1 / (overfished_th - Bcrit)
    ### connecting from (Bcrit, 0) to (overfished_th, 1)
    
    fish_stat_df <- fish_stat_df %>%
      mutate(fPrime = ifelse(b_bmsy < overfished_th & f_fmsy < fmax,
                             f_gradient(f_fmsy + (overfished_th - b_bmsy) * bcritslope,
                                        over_f = overfishing_th,
                                        under_f = underfishing_th,
                                        fmax = fmax,
                                        fmin_val = fmin_val),
                             NA),
             fPrime = ifelse(b_bmsy >= overfished_th & f_fmsy < fmax,
                             f_gradient(f_fmsy,
                                        over_f = overfishing_th,
                                        under_f = underfishing_th,
                                        fmax = fmax,
                                        fmin_val = fmin_val),
                             fPrime),
             fPrime = ifelse(is.na(fPrime), 0, fPrime), ### fill zeros everywhere unscored
             fPrime = ifelse(is.na(f_fmsy), NA, fPrime) ### but if no f_fmsy, reset to NA
      )
    return(fish_stat_df)
  }
  
  stock_status_df <- stock_status_layers %>%
    rescale_bprime_crit(bmax     = b_bmsy_underexploit_thresh,
                        bmax_val = b_bmsy_underexploit_penalty) %>%
    rescale_fprime_crit(fmax     = f_fmsy_overfishing_thresh,
                        fmin_val = f_fmsy_underfishing_penalty) %>%
    mutate(x_prod = ifelse(!is.na(fPrime), (fPrime * bPrime), bPrime),
           basis  = case_when(
             !is.na(fPrime) & !is.na(bPrime) ~ 'F_Fmsy, B_Bmsy',
             is.na(fPrime)  & !is.na(bPrime) ~ 'B_Bmsy only',
             is.na(bPrime)  & !is.na(fPrime) ~ 'F_Fmsy only'
           )) %>%
    dplyr::select(year, stockid, stocklong, species,
                  score = x_prod,
                  basis,
                  bPrime, fPrime,
                  b_bmsy, f_fmsy) 
```

Take the average scores for the 5 species with sub-stocks. Just doing a group_by with species and averaging scores will do this for all species (but only change the values for these sub-species). 

Remove stocks with just F_Fmsy - these stocks have no stock scores since we don't have a way to get a score from just F/Fmsy. Also roll all values forward to 2017.

```{r}
stock_scores <- stock_status_df %>%
  filter(year > 1979,
         basis != "F_Fmsy only") %>%
  group_by(species, year) %>%
  mutate(score = mean(score, na.rm = T)) %>%
  select(year, species, score, bPrime, fPrime, b_bmsy, f_fmsy, basis) %>%
  complete(year = 1980:2016) %>% #NOAA catch data only goes to 2016
  distinct() %>%
  mutate(gapfilled = ifelse(is.na(score), 1, 0)) %>%
  group_by(species) %>%
  fill(score, bPrime, fPrime, b_bmsy, f_fmsy, basis, gapfilled) %>%                #assigns most recent value to following years if missing, up to 2017
  fill(score, bPrime, fPrime, b_bmsy, f_fmsy, basis, gapfilled, .direction = "up") #assigns values to earlier years if missing

write.csv(stock_scores, file = "data/stock_scores.csv")  
```

## Visualize

```{r}
ggplot(stock_scores, aes(x = year, y = score)) +
  geom_line() +
  theme_bw() +
  facet_wrap(~species)
```

```{r kobe}
kobe_plot <- function(sp){
  
 ss_df <- stock_scores %>%
    filter(species == sp) %>%
    arrange(year) %>%
    mutate(last_bbmsy = last(b_bmsy),
           last_ffmsy = last(f_fmsy),
           last_datayear = last(year)) %>%
   ungroup()

generate_kobe_df <- function(f_fmsy_max = 2.5,
                             b_bmsy_max = 3.0,
                             reso       = 0.01,
                             bmax_val   = 0,
                             fmin_val   = 0,
                             weighting_b = 1) {

  kobe_raw <- data.frame(stock  = 1,
                     f_fmsy = rep(seq(0, f_fmsy_max, reso), each  = round(b_bmsy_max/reso) + 1),
                     b_bmsy = rep(seq(0, b_bmsy_max, reso), times = round(f_fmsy_max/reso) + 1))

  kobe <- kobe_raw %>%
    rescale_bprime_crit(bmax = b_bmsy_underexploit_thresh,
                        bmax_val = bmax_val) %>%
    rescale_fprime_crit(fmax = f_fmsy_overfishing_thresh,
                        fmin_val = fmin_val) %>%
    mutate(x_geom  = (fPrime * bPrime),
           x_arith = (fPrime + bPrime) / 2)

  return(kobe)
}

bbmsy_lim <- max(round(max(ss_df$b_bmsy, na.rm = TRUE) + .1, 1), 3)
ffmsy_lim <- max(round(max(ss_df$f_fmsy, na.rm = TRUE) + .1, 1), 2.5)
  
kobe_df <- generate_kobe_df(f_fmsy_max = ffmsy_lim,
                           b_bmsy_max = bbmsy_lim,
                           bmax_val = .25,
                           fmin_val = .25)


kobe_stock_plot <- ggplot(data = kobe_df, aes(x = b_bmsy, y = f_fmsy)) +
    theme_bw() +
    geom_raster(alpha = .8, aes(fill = x_geom)) +
    scale_fill_distiller(palette = 'RdYlGn', direction = 1) +
    labs(title = as.character(sp),
         x = 'B/Bmsy',
         y = 'F/Fmsy',
         fill = "Stock score") +
    geom_path(data = ss_df, 
              show.legend = FALSE,
              aes(x = b_bmsy, y = f_fmsy, group = sp),
              color = 'grey30') +
    geom_point(data = ss_df, 
               show.legend = FALSE,
              aes(x = last_bbmsy, y = last_ffmsy)) +
    geom_text(data = ss_df %>%
                mutate(year = ifelse(year/5 == round(year/5) | year == last_datayear, year, NA)), 
              aes(x = b_bmsy, y = f_fmsy, label = year), 
              hjust = 0, nudge_x = .05, size = 2)

return(kobe_stock_plot)
}
```

Apply function to all species in the stock_scores data frame. This does not work for the sub-stock species so we need to remove those.

```{r, fig.width = 12, fig.height = 8}
sp <- stock_scores %>%
  filter(basis == "F_Fmsy, B_Bmsy",
         gapfilled == 0,
         !species %in% c("monkfish", "yellowtail flounder", 
                             "winter flounder", "windowpane flounder", "haddock", "atlantic cod"))

plots <- lapply(unique(sp$species), kobe_plot)
cowplot::plot_grid(plotlist = plots[1:4])
cowplot::plot_grid(plotlist = plots[5:8])
cowplot::plot_grid(plotlist = plots[9:12])
cowplot::plot_grid(plotlist = plots[13:16])
cowplot::plot_grid(plotlist = plots[17:20])
cowplot::plot_grid(plotlist = plots[21:24])
cowplot::plot_grid(plotlist = plots[25:28])
```

## Save layer to toolbox

Save cleaned up version for toolbox
```{r}
ss_toolbox <- stock_scores %>%
  left_join(noaa) %>%
  left_join(rgn_data) %>%
  filter(year > 2004) %>%
  select(year, species, score, rgn_id, rgn_name)

write.csv(ss_toolbox, file = file.path(dir_calc, "layers/fis_stockscores.csv"))
```
