---
title: 'OHI-Northeast: Coastal Access'
author: "*Compiled on `r date()` by `r Sys.info()['user']`*"
output: 
  html_document:
    code_folding: show
    toc: true
    toc_depth: 3
    toc_float: yes
    number_sections: false
    theme: cerulean
    highlight: haddock
    includes: 
      in_header: '~/github/ne-prep/src/templates/ohi_hdr.html'
  pdf_document:
    toc: true
---

``` {r setup,  message = FALSE, warning = FALSE}
knitr::opts_chunk$set(fig.width = 6, fig.height = 4, fig.path = 'figs/',
                      message = FALSE, warning = FALSE)

source('~/github/ne-prep/src/R/common.R')  ### an OHINE specific version of common.R

dir_git <- '~/github/ne-prep'
dir_anx <- file.path(dir_M, 'git-annex/neprep')

#libraries
library(tidyverse)
library(sf)
#install.packages("gmapsdistance")
library(gmapsdistance)  # for getting info from the API
```

---

#Data Source 

**Reference**: NOAA [Environmental Sensitivity Index](https://response.restoration.noaa.gov/maps-and-spatial-data/download-esi-maps-and-gis-data.html)

**Downloaded**: August, 2019

**Description**:  Spatial point data identifying biological and human use resources. 

**Native data resolution**: Point data

**Time range**: NA. There are datasets from different time periods between 2001 and 2016 but we combine all datasets as a single representative layer, therefore the time does not play a role in the final coastal access layer.

**Format**:  Geodatabase/shapefile/point file

***

# Load Data

Load all the individual state point shapefiles
```{r}
nh <- read_sf("state_coastal_access/data/coastal_access_shapefiles/nh_coast_access.shp")
me <- read_sf("state_coastal_access/data/coastal_access_shapefiles/me_coast_access.shp")
ny <- read_sf("state_coastal_access/data/coastal_access_shapefiles/ny_coast_access.shp")
ri <- read_sf("state_coastal_access/data/coastal_access_shapefiles/ri_coast_access.shp")
ma <- read_sf("state_coastal_access/data/coastal_access_shapefiles/ma_coast_access.shp")
ct <- read_sf("state_coastal_access/data/coastal_access_shapefiles/ct_coast_access.shp")
```

# Buffer points

Applying a 2 mile buffer to each point

```{r}
nh_buff <- st_buffer(nh, dist = 3218.69) #there are 3218.69 meters in 2 miles
ny_buff <- st_buffer(ny, dist = 3218.69)
me_buff <- st_buffer(me, dist = 3218.69)
ma_buff <- st_buffer(ma, dist = 3218.69)
ri_buff <- st_buffer(ri, dist = 3218.69)
ct_buff <- st_buffer(ct, dist = 3218.69)
```

# Combine

We are going to combine all points from each layer

```{r}
all <- nh_buff %>%
  mutate(rgn_name = "New Hampshire") %>%
  rbind(ny_buff) %>%
  rbind(me_buff) %>%
  rbind(ma_buff) %>%
  rbind(ct_buff) %>%
  rbind(ri_buff)
```

# Try gmapsdistance

Results:
Time (seconds)
Distance (metres)
Status (i.e. could the calculation be made?)

```{r, echo = F}
set.api.key(Sys.getenv("GOOGLE_ACCESS_TOKEN"))
```


```{r}
small <- ny[1:10,]

m <- st_distance(small)
k <- as.numeric(m)
d <- as.data.frame(k[1:10])

df <- small %>%
  mutate(
    lead = geometry[row_number() + 1],
    dist = st_distance(geometry, lead, by_element = T), #calculate distance between points
  )

#can we use st_distance to help us identify points that would be to ofar apart so we only use gmapsdistance on points that are within 2 miles (as the crow flies)? if the straightest line between two points is 3 miles, we could assume that the drive between thost two points is at a minimum 3 miles which is too far. so we only run gmapsdistance on points that are 2miles and under?


#try gmapsdistance

#first convert to latlong

small_lat_long <- small %>%
  st_transform("+init=epsg:4326") %>%
  mutate(id = row_number(),
         long = unlist(map(.$geometry,1)),
         lat = unlist(map(.$geometry,2)),
         point = paste0(lat, "+",long))

out <- data.frame()

for(i in 1:(nrow(small_lat_long)-1)){
 
  #get first point
  o = filter(small_lat_long, id == i)
  
  out2 <- data.frame()
  
  for(j in i:(nrow(small_lat_long)-1)){
    
    #get next point
    d = filter(small_lat_long, id == j+1) 
    
    #calculate the distance first using st_distance, which calculates "as the crow flies"
    dist_crow = st_distance(o$geometry, d$geometry, by_element = T) 
    
    #if distance as the crow flies is less than or equal to 2 miles (3218 meters) then we run gmapsdistance otherwise we ignore and go to next
    if(as.numeric(dist_crow) > 3218.69) {break}
    
     r <- gmapsdistance(origin = o$point, destination = d$point, mode = "driving")
     
     dist <- r$Distance/1609.34
     
     print("running gmapsdistance")
    
     df <- data.frame(miles = dist,
                       start = i,
                       end = j+1)
     out2 <- rbind(df, out2)
  
    }
    
      out <- rbind(out2, out) 
}

```


Do it for New Hampshire
```{r}
#function to calculate minimum distance for each point in each state
get_dist_bw_points <- function(state, name){
  
  #transform to lat long and create a point column that will be used for origin and destination
  #in gmapsdistance
  state_df <- state %>%
    st_transform("+init=epsg:4326") %>%
    mutate(id = row_number(),
           long = unlist(map(.$geometry,1)),
           lat = unlist(map(.$geometry,2)),
           point = paste0(lat, "+",long))

  #create empty dataframe
  out <- data.frame()

    for(i in 1:(nrow(state_df)-1)){
      
      print(i)
     
      #get origin
      o = filter(state_df, id == i) 
      
        #create another empty dataframe for this forloop
        out2 <- data.frame()
        
        for(j in i:(nrow(state_df)-1)){ #
        
          #get destination
          d = filter(state_df, id == j+1)
          
          #calculate the distance first using st_distance, which calculates "as the crow flies"
          dist_crow = st_distance(o$geometry, d$geometry, by_element = T) 
    
          #if distance as the crow flies is less than or equal to 2 miles (3218 meters) then we run gmapsdistance otherwise we ignore and go to next
          if(as.numeric(dist_crow) > 3218.69) {next}
          
          #get distance between two points
          r <- gmapsdistance(origin = o$point, destination = d$point, mode = "driving")
          
           print(sprintf("running gmapsdistance i = %s j = %s",i,j))
           
          #convert distance to miles
          dist <- r$Distance/1609.34
          
          #store info in dataframe 
          df <- data.frame(miles = dist,
                           start = i,
                           end = j+1)
       
          out2 <- rbind(df, out2)
      
        }

      out <- rbind(out2, out) 
    }
  
    return(out)
}

nh_data <- get_dist_bw_points(nh, "New Hampshire")

write.csv(nh_data, "data/nh_min_dist_per_point.csv")
```

Do R

# Calculate score

We want each point to be overlapping with at least two other points. This would indicate that there are access points every two miles.

```{r}
ny_pts <- ny[1:3,]


distances <- gmapsdistance::gmapsdistance(
  origin = cam_pcd,  # start point of journey
  destination = cum_pcd,  # end point of journey
  mode = "driving",  # driving time
  shape = "long"  # format of output data (origin and destination as cols)
)
```


#Save

```{r}
write_sf(all, "data/coastal_access_shapefiles/nh_coast_access.shp", quiet = TRUE, delete_layer = TRUE)
```










